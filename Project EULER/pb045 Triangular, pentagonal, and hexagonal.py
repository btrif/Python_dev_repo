#!/usr/bin/python
# Solved by Bogdan Trif @ 17 Sep 2016 (10:32)
#The  Euler Project  https://projecteuler.net
'''
Triangular, pentagonal, and hexagonal       -       Problem 45
Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
'''
import time
from math import sqrt
tria=[]
penta=[]
hexag=[]
triapenta=[]

def computeTPH(n):
    t = (-1+sqrt(1+(8*n)))/2
    p = (1+sqrt(1+(24*n)))/6
    h = (1+sqrt(1+(8*n)))/4
    print('Indexes :    T=',t,'   P=',p,'  H=',h)


def tria_positive_root(n):
    #a*x**2+x-2*n=0
    w = (-1+sqrt(1+(8*n)))/2
    if w == int(w):
        return True     # return w
        #print(w)
    elif w != int(w):
        return False

def penta_positive_root(n):
    w = (1+sqrt(1+(24*n)))/6
    if w == int(w):
        return True     # return w
    elif w != int(w):
        return False

def hexag_positive_root(n):
    w = (1+sqrt(1+(8*n)))/4
    if w == int(w):
        return True     # return w
    elif w != int(w):
        return False
######################### END FUNCTIONS ########################

print(' ---------- My first METHOD - it works, investigates 10^9 numbers / 30 min, therefore it is slow and PRIMITIVE METHOD ------------ ')

t1  = time.time()
                                                                            # 10^9 - 2*10^9
for q in range(1533770000 , 1533780000):                     # 1 - 1.000.000.000 completed,    	10.000.000 numbers in 1/2 min ,Completed in : 29.673 s
    if (tria_positive_root(q) == True and penta_positive_root(q) == True and hexag_positive_root(q) ==True) :
        print ('T P H numbers :   ',q)

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')

print('-----'*30)

print(' -------My second METHOD - EFFICIENT --------- ')
# since any hexagonal number is also triangular it only checks if a pentagonal number is hexagonal
t1  = time.time()

for n in range(166, 100000):
        P = (n*(3*n-1))//2
        h = (1+sqrt(1+(8*P)))/4
        if h%1 == 0 :
                print ('T P H number :   ',P,'       P_n:     ', n)
                break

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')          # Completed in : 0.251 s,       Completed in : 0.071 s

print('--------Using while loops, a little slower than FOR loop  ------------')

t1  = time.time()
n=165
while  n < 100000:
        n += 1
        P = (n*(3*n-1))//2
        h = (1+sqrt(1+(8*P)))/4
        if h % 1 == 0:
                print ('T P H number :   ',P,'       P_n:     ', n)
                break

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')              # Completed in : 0.301 s,   Completed in : 0.097 s

print('-----'*30)

print('---'*20,' TESTS ', '---'*20)

X=57722156241751
print('Triangular number :',tria_positive_root(X))
print('Pentagonal number :',penta_positive_root(X))
print('Hexagonal number :',hexag_positive_root(X))
computeTPH(X)

print('-----'*30)

y=50
for n in range(y):
    T = (n*(n+1))//2
    P = (n*(3*n-1))//2
    H = n*(2*n-1)
    tria.append(T)
    penta.append(P)
    hexag.append(H)

print('First ',y,'  T P H numbers (hexagonal numbers are also triangular numbers : ')
print('T:  ','Max:',max(tria) ,tria)
print('P:  ','Max:',max(penta) ,penta)
print('H:  ','Max:',max(hexag) ,hexag)

##################################################

print('\n=============FAST SOLUTIONS FROM THE FORUM : =================')
print('This is  fast, never thought of ')
t1  = time.time()

for x in range(285,100000):
	c = (x**2 + x)/2
	y = (.5 + sqrt(.25 + 6*c))/3
	z = (1 + sqrt(1 + 8*c))/4

	if y - int(y) == 0 and z - int(z) == 0:
		print ('x = %d' % x)
		print ('y = %d' % y)
		print ('z = %d' % z)

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')

print('------'*30)

print('---------------INCREDIBLE FAST SOLUTION -------------'*3)
# finds all  numbers, you just set the down limit, the nex number is above this limit, REALLY FAST

t1  = time.time()
i = 0
while True:
    i += 1
    a = (i * (i + 1)) / 2
    b = (1 + sqrt(1 + 24 * a)) / 6
    c = (1 + sqrt(1 + 8 * a)) / 4
    if (b % 1) == 0.0:
        if (c % 1) == 0.0:
            print (a)
            if a > 40755:               #  100000000000:               #if a > 40755:
                break

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')              #  Completed in : 0.203 s

print('--------------- REALLY FAST SOLUTION -------------'*3)

t1  = time.time()

def solution():
    b = 286
    c = 0
    d = 0
    pentest = 0
    hextest = 0
    while c == 0:
        d = b*(b+1)/2
        pentest = (((24*d+1)**.5)+1)/6
        hextest = (((8*d+1)**.5)+1)/4
        if pentest % 1 == 0:
            if hextest % 1 == 0:
                break
        b = b + 1
    return d

print (solution())

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')


print('------'*30)
print('--------------- REALLY FAST SOLUTION -------------'*3)

t1  = time.time()

for i in range(1,100000):
	d=(1+12*(i*i+i))**0.5
	if(int(d)==d and (1+d)%6==0):
		j=(1+d)//6
		d1=(4+16*(3*j*j-j))**0.5
		if(int(d1)==d1 and (2+d1)%8==0):
			print((j*(3*j-1))//2)

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')          #Completed in : 0.225 s

print('------'*30)
t1  = time.time()

def PE045(maxi=2):
  nb=0
  t, s = 26, 15
  while nb<maxi:
        nb+=1
        t,s = 18817*t+32592*s, 10864*t+18817*s # <<<<  x8 speed on the Pell equation

        #x=racine(t-1) # <racine> not given, would be a spoil.
        x=int((t-1)**0.5) # correct until 7th, only !!!

        y=s//x
        m, n = (x+1)//6, (y+1)//4
        print(nb, "th number is", n*(2*n-1))
  return

PE045(15)
t2  = time.time()
print('\nCompleted in :', (t2-t1)/1000000,  's\n')      #Completed in : 1.0001659393310547e-09 s
'''

from sets import *

def T(n):
    return (n*(n+1))/2

def P(n):
    return (n*(3*n-1))/2

def H(n):
    return n*(2*n-1)

t1  = time.time()
Ts = Set([T(x) for x in range(286,100000)])
Ps = Set([P(x) for x in range(166,100000)])
Hs = Set([H(x) for x in range(144,100000)])

print (Ts.intersection(Ps.intersection(Hs)))

t2  = time.time()
print('\nCompleted in :', round((t2-t1),3), 's\n')

'''


'''
for q in range(1, 1000):                     # 1 - 1.000.000.000 completed
    if (tria_positive_root(q) == True and penta_positive_root(q) == True and hexag_positive_root(q) ==True) :
        print (q)

# It seems that the while loop doesn't work well with functions
t1  = time.time()
m=1
while (m < 1000) :                     # 1 - 1.000.000.000 completed
    if (tria_positive_root(m) == True and penta_positive_root(m) == True and hexag_positive_root(m) ==True) :
        print (m)
        m+=1
t2  = time.time()
print('\nCompleted in :', (t2-t1)*1000, 'ms')


print('-----'*30)
'''