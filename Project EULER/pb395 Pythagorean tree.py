#  Created by Bogdan Trif on 23-05-2018 , 6:26 PM.
# Â© o(^_^)o  Solved by Bogdan Trif  @
#The  Euler Project  https://projecteuler.net
'''
                Pythagorean tree            -           Problem 395

The Pythagorean tree is a fractal generated by the following procedure:

Start with a unit square. Then, calling one of the sides its base (in the animation, the bottom side is the base):

Attach a right triangle to the side opposite the base,
with the hypotenuse coinciding with that side and with the sides in a 3-4-5 ratio.
Note that the smaller side of the triangle must be on the 'right' side with respect to the base (see animation).

Attach a square to each leg of the right triangle, with one of its sides coinciding with that leg.
Repeat this procedure for both squares, considering as their bases the sides touching the triangle.
The resulting figure, after an infinite number of iterations, is the Pythagorean tree.

p395_pythagorean.gif

It can be shown that there exists at least one rectangle, whose sides are parallel to the largest square of the Pythagorean tree,
which encloses the Pythagorean tree completely.

Find the smallest area possible for such a bounding rectangle, and give your answer rounded to 10 decimal places.

'''
import time, zzz
from math import cos, acos, sqrt, sin, asin, pi, tan, atan, atan2

# @ 2018-05-23
# Obviously , we must use recursion.
# Basically the tree converges vertically to a maximum point and horizontally to two maximum points.
# Must find those three points and the problem is solved.


###################################################################
###########         The properties of the 3,4,5 Pythagorean Triangle        ##########

print('\n ###########         The properties of the 3,4,5 Pythagorean Triangle        ########## ')

A = [ acos(4/5)*180/pi , acos(3/5)*180/pi  ]
E = [ 4/5, 3/5 ]

c1_ = lambda base : 3.2*base / 5
c2_ = lambda base : 1.8*base / 5
a_ = lambda base : 4*base/5
b_ = lambda base : 3*base/5
h_ = lambda a : 3*a /5
alpha_ =  acos ( 4/5 )
beta_ =  acos ( 3/5 )


print('the two segments of the normal through the angle of 90 degrees :          c1 = ' ,c1_(1) ,   '    c2 = ' ,c2_(1)     )
print('cathetes         a = ' ,a_(1) ,   '    b = ' ,b_(1)     )
print('Height :   h = ' ,h_(4/5) )
print('alpha_ : rad =  ' ,alpha_ , '    deg =', alpha_*180/pi )
print(  'beta_ : rad = ' ,beta_ ,'     deg = ',beta_ *180/pi )
print('-----------')

# OBSERVATIONS :      @ 2018-12-15, 19:00
# 1.  The difficulty resides in maintaining a correct form of the base down and up vectors .
# After many angles transformations they will change orientations and we must keep a variable
# with its orientation, its state.
# So when we translate a vector clockwise or counterclockwise we must keep into account if the new angle
# changed the top base orientation. VERY IMPORTANT


###################################################################


print('\n--------------------------TESTS------------------------------')
t1  = time.time()




t2  = time.time()
print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')

print('\n-------------   My FIRST ATTEMPT SOLUTION, close but not enough  ------------------ \n')
t1  = time.time()


def translate_base( A, B , orientation  ) :        # Made @ 2018-12-15, 20:00, working GOOD !!
    '''Given the two points of the bottom base, left and right, generate the second pairs of points C & D
        which represent the top of the square or the other base, the TOP BASE
    :param side_len:
    :param rotation : clockwise or anti-clockwise to know in which direction we are going !
    :return: C, D, pair of points representing the upper BASE, m = slope    '''

    (x1, y1), (x2, y2) =  A, B
    dx, dy = x2-x1,  y2-y1

    try : m = dy/dx
    except ZeroDivisionError :      m = -1e20

#     print('m = ', m, '  dx = ', dx, '    dy=', dy)

    if m >= 0 : dx, dy = abs(dx), -abs(dy)
    if m < 0  : dx, dy = abs(dx), abs(dy)
#     print('after m = ', m, '  dx = ', dx, '    dy=', dy)

    if orientation == 'up' :
            C = x1 + dy, y1 + dx
            D = x2 + dy, y2 + dx
    if orientation == 'down' :
            C = x1 - dy, y1 - dx
            D = x2 - dy, y2 - dx

    # print(' A=', A, '    B=', B , '  ;   Opposite BASE :        C=', C , '    D=', D )
    return C, D, orientation
translate_base(  (0,5), (0,0),  'up' )

print()

# # @2018-06-07 - I cant think !!!! I cant think ! I am blocked here


def next_orientation(orientation):
    if orientation == 'down' : return 'up'
    else : return 'down'


def next_base(A, B, orientation, direction):
    ''':Description: Gets either right (small base) either left (big base) depending
    on which direction is chosen. It does this by finding first the point E of the intersection
    of the two cathetes
    :param A: tuple, containing the point down base
    :param B: tuple, containing the point down base
    :param orientation: string, 'up' or 'down' containing the orientation on which to translate
    param direction:, string, 'left' (big base) or 'right' (small baseab)
    :return: next_base, either left, either right          '''

#     A, B, orientation, m = translate_base(A, B ,  orientation )
    dx, dy = B[0]-A[0] , B[1]-A[1]
    try :  m = dy/dx                        # slope of the base
    except ZeroDivisionError :
        # print('asa')
        m = -10**20

    #  We want that no matter how I put the base points order, I will always have the following rules
    # meaning that point A will always correspond to the closest cathete a => left side of the base
    if orientation =='down' :
        A, B = sorted((A, B), reverse=True)
    if orientation =='up' :
        A, B = sorted((A, B), reverse=False)

    # print('top base=   A = ', A ,'    B=', B, '  m=', m ,'  ; orientation= ', orientation )
    # print( 'dx, dy = ', dx, dy , '     direction : ', direction )

    # BASE & BASE_ANGLE
    base = sqrt( dx**2 + dy**2 )
    base_angle = atan(m)
    base_angle_deg = base_angle*180/pi
    # print('base= ', base,'    m = ', m )
    # print('= INITIAL = base_angle : rad = ',base_angle , ' base_angle_deg = ' ,base_angle_deg  )

    if direction == 'left' :
        # BASE ANGLE CORRECTIONS
        if orientation =='down' :
            base_angle = base_angle + pi
            base_angle_deg = base_angle*180/pi

        # print('base_angle : rad = ',base_angle , ' base_angle_deg = ' ,base_angle_deg  )

        a = a_(base)
        alpha = base_angle + alpha_
        m_a  = tan(alpha)               # slope of cathete a
        # print('a = ', a, '    m_a = ', m_a  )
        # print('alpha :  rad =  ', alpha,'     deg =' ,alpha*180/pi   )

        dx_a, dy_a = a *cos(alpha) , a *sin(alpha)

        # print('dx_a =  ', dx_a , '     dy_a =  ', dy_a  )

        E = A[0] + dx_a , A[1] + dy_a

        if ((m >= 0 and m_a < 0)  or ( m < 0 and m_a >= 0 )) and ( abs(m) >= 1 or abs(m_a) >= 1  ) :
            orientation = next_orientation(orientation)

        # print('A = ', A ,'    E = ', E)

        C, E, orientation = translate_base(A, E, orientation)
        return C, E, orientation, direction


    if direction == 'right' :
        # BASE ANGLE CORRECTIONS
        if orientation =='up' :
            base_angle = base_angle + pi
            base_angle_deg = base_angle * 180 /pi

        # print('base_angle : rad = ',base_angle , ' base_angle_deg = ' ,base_angle_deg  )

        b =  b_(base)
        beta = base_angle - beta_
        m_b  = tan(beta)               # slope of cathete b
        # print('b = ', b ,'    m_b = ', m_b  )
        # print('beta :  rad =  ', beta,'     deg =' ,beta*180/pi   )

        dx_b, dy_b  = b *cos(beta) , b *sin(beta)
        # print('dx_b =  ', dx_b , '     dy_b =  ' , dy_b  )
        E = B[0] + dx_b , B[1] + dy_b

        if ((m > 0 and m_b < 0)  or ( m < 0 and m_b > 0 )) and ( abs(m) >= 1 or abs(m_b) >= 1  ) :
            orientation = next_orientation(orientation)
        # print('B = ', B ,'    E = ', E)

        D, E, orientation = translate_base(B, E, orientation)
        return D, E, orientation, direction



next_base( (4, 4), (6, 9) ,'down', 'left')


def func(f):
    def wrapper(x):
        return f(x)
    return wrapper



epsilon = 1e-12

xxy = [0, 0, 0, 0]         # x_min, x_max, y_max


def pythagorean_tree( A, B, orientation, extrema, var  ) :
    # main recursion execution Code

    if extrema == 'x_min' :     minimax, ind = func(min), 0
    if extrema == 'x_max' :    minimax, ind = func(max), 0
    if extrema == 'y_min' :     minimax, ind = func(min), 1
    if extrema == 'y_max' :    minimax, ind = func(max), 1


    A1, B1, orientation1, direction1 = next_base(A, B, orientation, 'left')
    A2, B2, orientation2, direction2 = next_base(A, B, orientation, 'right')

    m1, m2 = (A1[ind] , B1[ind]), (A2[ind] , B2[ind])   #   We make m1, m2 to be two separate pairs of min or max, after case
    if  minimax( ( minimax( m1) , minimax(m2) ) ) in m1  :          # if min/max value is found in first pair m1
        if var != minimax (  ( var,   minimax( m1)  ) ) :              # then compare it with the value had in var, AND if var is min/max :
            A, B, orientation, direction = A1, B1, orientation1, direction1

    else :
        if var != minimax (  ( var,   minimax( m2)  ) ) :
            A, B, orientation, direction = A2, B2, orientation2, direction2

    print('A =', A ,'    B =', B ,'    orientation =', orientation, '     direction=', direction ,'     var : ' , var )

    if abs( var -  minimax( (A[ind] , B[ind]) ) ) < epsilon :
        print('\nvar = ', var)
        return var

    var = minimax( (A[ind] , B[ind])  )
    print('var = ', var)

    # recursive call
    return pythagorean_tree(A, B, orientation, extrema, var  )



# @2018-12-18, 11:16 - I must change order between translate_base and calculate the two bases :
# I must first start with translate base, because the two bases left and right have a common point
# which often times is either the biggest => break recursion , and sometimes smaller =>
# break recursion too !!!

# xxy[0] = pythagorean_tree( (0, 1 ) , (1, 1), 'up' , 'x_min', 0  )
# xxy[1] = pythagorean_tree( (0, 1 ) , (1, 1), 'up' , 'x_max', 0  )
# xxy[2] = pythagorean_tree( (-1.5736319999999995, 1.6389760000000007), (-1.7538559999999992, 2.118208), 'down' , 'y_min', 1.638976 )
xxy[3] = pythagorean_tree( (0, 1 ) , (1, 1), 'up' , 'y_max', 0  )
print('xxy = ', xxy )

Area = ( (xxy[1]-xxy[0]) * (xxy[3] - xxy[2]) )
print('Area = ',   Area  )
print('Area = ',   round( Area, 10 )  )

# @ 2018-12-19 -  I must rethink the problem, I get good values for the x_min and x_max, but wrong values
#     even if they are close for y_min and y_max

t2  = time.time()
print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')


# IDEAS :
# https://matthew-brett.github.io/teaching/rotation_2d.html
# https://en.wikipedia.org/wiki/Rotation_matrix

print('\n============       MY SECOND SOLUTION      ==============')
t1  = time.time()

A = [ acos(4/5)*180/pi , acos(3/5)*180/pi  ]
E = [ 4/5, 3/5 ]

c1_ = lambda base : 3.2*base / 5
c2_ = lambda base : 1.8*base / 5
a_ = lambda base : 4*base/5
b_ = lambda base : 3*base/5
h_ = lambda a : 3*a /5
alpha_ =  acos ( 4/5 )
beta_ =  acos ( 3/5 )

v1 = [ [0, 0], [0, 1 ]  ]









t2  = time.time()
print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')

# print('\n===============OTHER SOLUTIONS FROM THE EULER FORUM ==============')
# print('\n--------------------------SOLUTION 1,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 2,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 3,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 4,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 5,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 6,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 7,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 8,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 9,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 10,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 11,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 12,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')

