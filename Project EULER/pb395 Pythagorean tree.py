#  Created by Bogdan Trif on 23-05-2018 , 6:26 PM.
# Â© o(^_^)o  Solved by Bogdan Trif  @
#The  Euler Project  https://projecteuler.net
'''
                Pythagorean tree            -           Problem 395

The Pythagorean tree is a fractal generated by the following procedure:

Start with a unit square. Then, calling one of the sides its base (in the animation, the bottom side is the base):

Attach a right triangle to the side opposite the base,
with the hypotenuse coinciding with that side and with the sides in a 3-4-5 ratio.
Note that the smaller side of the triangle must be on the 'right' side with respect to the base (see animation).

Attach a square to each leg of the right triangle, with one of its sides coinciding with that leg.
Repeat this procedure for both squares, considering as their bases the sides touching the triangle.
The resulting figure, after an infinite number of iterations, is the Pythagorean tree.

p395_pythagorean.gif

It can be shown that there exists at least one rectangle, whose sides are parallel to the largest square of the Pythagorean tree,
which encloses the Pythagorean tree completely.

Find the smallest area possible for such a bounding rectangle, and give your answer rounded to 10 decimal places.

'''
import time, zzz
from math import cos, acos, sqrt, sin, asin, pi, tan, atan

# @ 2018-05-23
# Obviously , we must use recursion.
# Basically the tree converges vertically to a maximum point and horizontally to two maximum points.
# Must find those three points and the problem is solved.




A = [ acos(4/5)*180/pi , acos(3/5)*180/pi  ]
E = [ 4/5, 3/5 ]



def get_top_base( A, B , rotation  ) :        # Made @ 2018-06-08, 00:00, working GOOD !!
    '''Given the two points of the bottom base, left and right, generate the second pairs of points C & D
        which represent the top of the square or the other base, the TOP BASE
    :param side_len:
    :param rotation : clockwise or anti-clockwise to know in which direction we are going !
    :return: C, D, pair of points representing the upper BASE    '''

    (x1, y1), (x2, y2) =  A, B

    dx, dy = x2-x1,  y2-y1

    if rotation == 'counter-clockwise' :
        dx2, dy2 =  -dy, dx
    if rotation == 'clockwise' :
        dx2, dy2 =  dy, -dx
    c = sqrt( dx**2 + dy**2 )

    if dy ==0 : dy2 = abs(dy2)        #   The case for the base with the slope m = 0 (horizontal base )

    # print( 'dx = ', dx, '    dy = ', dy,'     c= ' , c ,'    dx2= ', dx2,'    dy2= ', dy2 ) # , '    m= ', m,'    m2= ', m2,    )
    C = x1 + dx2 , y1 + dy2
    D = x2 + dx2 , y2 + dy2

    # print(' A=', A, '    B=', B , '  ;   Opposite BASE :        C=', C , '    D=', D )
    return C, D

print('  ********** get_top_base : *************     ')

# get_top_base( (9, 2) , ( 4 , 4 ), 'clockwise' )        #    works
# get_top_base( ( 4 , 4 ),( 6 , 9) ,  'clockwise' )        #  works
# get_top_base( ( 6 , 9) , ( 11 , 7 ), 'clockwise' )        #  works
# get_top_base(  ( 11 , 7 ),( 9 , 2) , 'clockwise' )        #  works

# get_top_base( ( 4 , 4 ),(9, 2) ,  'counter-clockwise' )        #   WORKS !    A, B must be opposite
# get_top_base(  ( 9 , 2) ,( 11 , 7 ),  'counter-clockwise' )
# get_top_base( ( 11 , 7 ),  ( 6 , 9) ,  'counter-clockwise' )


# get_top_base( ( 0 , 0 ),( 5, 0 ) ,  'clockwise' )
# get_top_base( ( 0 , 0 ),( 5, 0 ) ,  'counter-clockwise' )

# get_top_base( ( 0 , 0 ),( 0, 5 ) ,  'clockwise' )
# get_top_base( ( 0 , 0 ),( 0, 5 ) ,  'counter-clockwise' )



###################################################################
###########         The properties of the 3,4,5 Pythagorean Triangle        ##########

print('\n ###########         The properties of the 3,4,5 Pythagorean Triangle        ########## ')


c1_ = lambda base : 3.2*base / 5
c2_ = lambda base : 1.8*base / 5
a_ = lambda base : 4*base/5
b_ = lambda base : 3*base/5
h_ = lambda a : 3*a /5
alpha_ =  acos ( 4/5 )
beta_ =  acos ( 3/5 )


print('c1 = ' ,c1_(5) ,   '    c2 = ' ,c2_(5)     )
print('a = ' ,a_(5) ,   '    b = ' ,b_(5)     )
print('h = ' ,h_(4) )
print('alpha_ : rad =  ' ,alpha_ , '    deg =', alpha_*180/pi ,  '           beta_ : rad = ' ,beta_ ,'     deg = ',beta_ *180/pi )
print('-----------')

###################################################################

def get_base(A, B, rotation):           #@2018-06-09, 14:07 , Works perfectly
    ''':Description: Gets E point, which is the intersection of the two cathetes
    :param C: tuple of floats, left point (x_C, y_C ) of the base
    :param D: tuple of floats, right point (x_D, y_D ) of the base
    :return:           '''

    C, D = get_top_base(A, B ,  rotation )
    if (A[1]**2+B[1]**2) > (C[1]**2+D[1]**2) :
        orientation ='down'
    else : orientation = 'up'
    # print('orientation : ', orientation )


    dx0, dy0 = D[0]-C[0] , D[1]-C[1]
    # print( '   dx0, dy0 = ', dx0, dy0 , '     rotation : ', rotation )

    try :  m = dy0/dx0                        # slope of the base
    except ZeroDivisionError :
        # print('asa')
        m = 10**20

    base = sqrt(dx0**2 + dy0**2 )
    base_angle = atan(m)
    alpha = base_angle + alpha_

    # print('base =  ', base,'         dx0 = ', dx0, '         dy0 = ', dy0,'    m = ', m ,'    base_angle : rad = ',base_angle , '   deg = ',base_angle*180/pi  )
    a, b = a_(base), b_(base)
    c1 = c1_(base)
    h = h_(a)

    m_a  = h/c1               # slope of cathete a

    # print('a = ', a, '         b = ', b,'    c1 = ', c1,'    h = ', h ,'    m_a = ', m_a  )
    # print('alpha :  rad =  ', alpha,'     deg =' ,alpha*180/pi   )

    dx_a = a *cos(alpha)
    dy_a = a *sin(alpha)
    if rotation == 'clockwise' :
        if orientation =='down' :
            E = ( D[0] - dx_a,  D[1] - dy_a )
        if orientation =='up' :
            E = ( D[0] + dx_a,  D[1] + dy_a )

    if rotation == 'counter-clockwise' :
        if orientation =='down' :
            E = ( C[0] - dx_a,  C[1] - dy_a )
        if orientation =='up' :
            E = ( C[0] + dx_a,  C[1] + dy_a )

    # print('dx_a =  ', dx_a , '     dy_a =  ', dy_a ,'          middle point E  = ', E   )

    # print('C = ', C , '      E =' , E , '     D = ', D )
    if rotation == 'clockwise' :
        return  C, E
    if rotation == 'counter-clockwise' :
        return  C, E


# get_base( (6 ,9), (4 , 4) , rotation = 'counter-clockwise' )        #    middle point E  =  (12.12, 2.84)
# get_base( (9 ,2), (11 , 7) , rotation = 'counter-clockwise' )           #   middle point E  =  (2.880000000000001, 8.16)
# get_base(  (11 , 7) , (6 , 9 ), rotation = 'counter-clockwise' )
# get_base(  (4, 4 ) , (9, 2 ), rotation = 'counter-clockwise' )

# get_base(  (9 , 2) ,(4, 4), rotation = 'clockwise' )            #    middle point E  =  (10.16, 10.12)
# get_base(  (4, 4), (6 , 9) ,  rotation = 'clockwise' )              #   middle point E  =  (12.12, 2.84)
# get_base(  (6 , 9) , (11, 7),  rotation = 'clockwise' )
# get_base( (11, 7), (9 , 2)  ,   rotation = 'clockwise' )

get_base((0, 0), (5, 0), rotation ='clockwise')
# get_base( (5 , 0), (0, 0)  ,   rotation = 'counter-clockwise' )


# print('get_top_base : ', get_top_base( (0 , 5) ,(3.2, 7.4) )              )
# get_base ((2.4, 8.2), (5.60, 10.6))

print()
# def get_pythagorean_bases( C, D ) :
#     ''':Description: Given the two points of the top base of the square, compute
#         Pythagorean Triangle, by doing the following :
#         1. Finds the vertex of the cathetes ;
#         2.  computes the left base length
#     :param C: tuple of floats,  leftmost point coordinates, (x_C, y_C )
#     :param D: tuple of floats,  rightmost point coordinates, (x_D, y_D )
#     :return:
#     '''
#     dx0, dy0 = abs(D[0]-C[0]) ,abs(D[1]-C[1])
#     base_m = dy0/dx0                        # slope of the base
#     main_base = sqrt(dx0**2 + dy0**2 )
#     base_angle = acos(dx0/main_base)                       # omega represents the angle inclination of the main base
#     a, b = 4*main_base/5, 3*main_base/5
#     print('main_base =  ', main_base,'         a = ', a, '         b = ', b,'    base_angle = ', base_angle*180/pi, '    base_slope =  ', base_m )
#
#     c1 = cos(alpha) *a
#     h = sqrt(a*a - c1*c1)
#     print('alpha = ', alpha*180/pi , '    beta = ', beta*180/pi , '   c1 = ', c1 ,'   h = ', h )
#     # C1 =
#
#     c2 = cos(beta) *b
#     h2 = sqrt(b*b - c2*c2)
#     print('alpha = ', alpha , '    beta = ', beta , '   c2 = ', c2 ,'   h2 = ', h2 )
#
# # @2018-06-07 - I cant think !!!! I cant think !I am vblocked here
#
# # get_pythagorean_bases((0, 5) , (5, 5) )
#




print('\n--------------------------TESTS------------------------------')
t1  = time.time()

A, B = (0, 0 ) , (5, 0)
def pythagorean_tree( A, B  ) :
    x_max , y_min, y_max = 0, 0, 1e19
    E = get_base(A, B, 'clockwise')
    print('E : ', E)

    E = get_base(  B, A, 'counter-clockwise')
    print('E : ', E)


pythagorean_tree( A, B )


t2  = time.time()
print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')

print('\n================  My FIRST SOLUTION,   ===============\n')
# t1  = time.time()





# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')


# print('\n===============OTHER SOLUTIONS FROM THE EULER FORUM ==============')
# print('\n--------------------------SOLUTION 1,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 2,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 3,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 4,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 5,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 6,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 7,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 8,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 9,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 10,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 11,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')
#
#
# print('\n--------------------------SOLUTION 12,   --------------------------')
# t1  = time.time()
#
#
#
# t2  = time.time()
# print('\n# Completed in :', round((t2-t1)*1000,2), 'ms\n\n')

