#!/usr/bin/python
# Solved by Bogdan Trif @       Completed on Fri, 20 Jan 2017, 19:40
#The  Euler Project  https://projecteuler.net
'''
                    Optimum polynomial      -       Problem 101

If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term,
as there are infinitely many polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
                u_n = n**3: 1, 8, 27, 64, 125, 216, ...

Suppose we were only given the first two terms of this sequence.
Working on the principle that "simple is best" we should assume a linear relationship and predict
the next term to be 15 (common difference 7). Even if we were presented with the first three terms,
by the same principle of simplicity, a quadratic relationship should be assumed.

We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of a sequence.
It should be clear that OP(k, n) will accurately generate the terms of the sequence for n ≤ k,
and potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence,
it would be most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u_1.

Hence we obtain the following OPs for the cubic sequence:

                        OP(1, n) = 1	                                1, 1, 1, 1, ...
                        OP(2, n) = 7*n−6	                        1, 8, 15, ...
                        OP(3, n) = 6*n**2−11*n+6     	    1, 8, 27, 58, ...
                        OP(4, n) = n**3	                            1, 8, 27, 64, 125, ...
Clearly no BOPs exist for k ≥ 4.

By considering the sum of FITs generated by the BOPs (indicated in red above), we obtain 1 + 15 + 58 = 74.

Consider the following tenth degree polynomial generating function:

u_n = 1 − n + n**2 − n**3 + n**4 − n**5 + n**6 − n**7 + n**8 − n**9 + n**10

Find the sum of FITs for the BOPs.

'''
import time
import numpy as np

print('\n--------------------------TESTS------------------------------')




#######    Test Polynomial
# poly_101 = lambda n: n**3

# The polynomial from our problem !!
poly_101 = lambda n: 1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10


print('\n--------------------------')

def get_Weighting_function_L(n, coeff, degree):
    ''':Description: function to compute the coefficients of the main function interpolation
    :param n: int, the x-term, or n of the polynomial to test for
    :param coeff: int, the Weighted function is calculated for a particular coeff
    :param degree: int, degree of the polynomial
    :return: the weighted L_i parameter corresponding the input coeff                   '''
    N_coeff = list(range(1, degree+2))
    N_coeff.remove(coeff)
    # print(N_coeff)
    P = 1
    for j in N_coeff :
        P *= ( n-j ) / ( coeff-j )

    return P

print('get_Weighted_function_L : \t', get_Weighting_function_L(3, 2, 1) )

print('\n--------------------------')



def get_function_interpolation( degree):
    '''This function works on the formula :
        f(n) = Ʃ {i=0, n}  L_i(n) * f(n_i)  where  L_i are the weighted function coefficients
        L_i = Π {j=0, j !=i } (n-n_i) / (n_i-n_j)
        Uses the get_Weighted_function_L and a pre-defined polynomial function
    :param degree: of the polynomial
    :return: the next FIT Firts Incorrect Term of the polynomial representing the interpolation
        of the polynomial                                       '''
    S=0
    FIT = degree+2              # FIT = First Incorrect Term
    for coeff in range(1, degree+2):
        S+= poly_101(coeff)*get_Weighting_function_L(FIT, coeff, degree)
    return S


print('\nget_function_interpolation : \t', get_function_interpolation(0) )

print('\n============  My FIRST SOLUTION,  LAGRANGE Polynomial Interpolation  ===============\n')
t1  = time.time()

FIT_SUM = 0
for n in range(0, 10):
    u_n = poly_101(n)
    FIT = round(get_function_interpolation(n))
    FIT_SUM += FIT
    print('Polyn degree :  '+str(n)+'             Real Polyn val =', u_n, '               FIT = ', FIT )

print('\nSum of FITs for the BOPs : ' , round(FIT_SUM))                    # ANSWER : 37076114526


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')      #   Completed in : 0.999928 ms


#### GENERAL IDEAS :
# 1.   Can be solved by Lagrange Polynomial Interpolation
# 2.   Newton polynomials Interpolation       http://en.wikipedia.org/wiki/Newton_polynomial
#               https://upload.wikimedia.org/math/d/f/c/dfce9a0c44bce61eb37993924efeb747.png
# 3.   Discrete sequences - "simple" method of calculating the next term in a sequence
# 4.     Gaussian elimination

print('\n===============OTHER SOLUTIONS FROM THE EULER FORUM ==============')
print('\n--------------------------SOLUTION 0, LAGRANGE Interpolation, Very Shot=rt  --------------------------')
t1  = time.time()

# ====Fri, 4 Jul 2008, 03:23, Tirian, USA
# Lagrange.  I guess I was in a mood for list comprehension.

def problem101():
    def pi(lst): return reduce(lambda i,j: i*j, lst) if len(lst) else 1

    def findpoint(n):
        pts = set(map(float, range(1, n)))
        x = float(n)
        return sum([pi([(x-i)/(j-i) for i in pts - set([j])])*f(j) for j in pts])

    def f(n): return sum([(-n)**i for i in xrange(11)])

    return sum([findpoint(i) for i in xrange(1,12)])


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

print('\n--------------------------SOLUTION 1, numpy Linear Algebra  --------------------------')
t1  = time.time()

# ====   Wed, 26 Oct 2016, 10:44, mbh038, England
# About 5 ms in Python, using linear algebra.


def u(n):
    return sum([(-n)**i for i in range(11)])

def mbh038(limit):
    c=[u(n) for n in range(1,limit+1)]
    sumfit=1
    for k in range(2,limit+1):
        ck = c[:k]
        bk = np.array([[(x)**i for i in range(k)] for x in range(1,k+1)])
        bkinv = np.linalg.inv(bk)
        coeffs = np.matmul(bkinv,ck)
        fit = np.dot([(k+1)**x for x in range(k)],coeffs)
        sumfit += fit
    print('\n',sumfit)

mbh038(10)

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

print('\n--------------------------SOLUTION 2,  numpy linalg Linear Algebra --------------------------')
t1  = time.time()

# ===== Wed, 16 Nov 2016, 12:40, aolea, Spain
# Also solved with matrixes (thanks numpy)



def u(n):
    '''
    Computes the n-th term of the sequence from generator.
    Parameters:
    -----------
    n: position of the term.Integer

    Returns:
    --------
    value of the n-th term of the sequence.Integer
    '''
    return 1-n+n**2-n**3+n**4-n**5+n**6-n**7+n**8-n**9+n**10

def FIT(k):
    '''
    Computes the  first incorrect term (FIT) generated by the optimum
    polynomial for the first k terms of the sequence.Integer.

    Parameters:
    -----------
    k: numbers of term to be generated correctly by the optimum polynomial
    before the FIT.Integer

    Returns:
    --------
    value of the FIT.Integer.
    '''
    n = k + 1                                     # position of the FIT in the sequence
    u_terms = np.zeros(shape=(k))                 # values of the terms from the real generator
    n_terms = np.zeros(shape=(k))                 # powers of n to compute the FIT
    aux = np.zeros(shape=(k, k))
    for i in range(k):
        for j in range(k):
            aux[i][j] = (i + 1) ** (k - j - 1)
        u_terms[i] = u(i + 1)
        n_terms[i] = n ** (k - i - 1)

    aux_inverse = np.linalg.inv(aux)
    coeficients = np.matmul(aux_inverse, u_terms) # coeficients of the optimum polynomial
    return int(round(np.matmul(n_terms,coeficients),0))

suma = 0
for i in range(1,11):
    suma += FIT(i)
print(suma)



t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

print('\n--------------------------SOLUTION 3,  numpy - Linear Algebra --------------------------')
t1  = time.time()

# ===== Thu, 17 Nov 2016, 16:57, DidierDubois, Switzerland
#

v = [ 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1]
def equation(n):
    return sum( [ a*n**b  for a, b in zip( v, range(len(v)) ) ] )


def FIIT(n, equa ):
    A = [ [ i ** x for x in range(n) ] for i in range(1, n+1) ]
    B = [ equa(i) for i in range(1, n+1) ]
    X = np.linalg.solve(A, B)

    vec = [ (n+1) ** x for x in range(n) ]
    return np.dot(X, vec)

vec = [  FIIT(i, equation ) for i in range(1, len(v)) ]

print (sum(vec))

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

print('\n--------------------------SOLUTION 4,  numpy polyfit function  --------------------------')
t1  = time.time()

# ===== Tue, 26 Jan 2016, 11:14, sO3SrLCr4Rqb00Zr..., Japan
# Too easy with numpy:
# Just find the first j+1 points of a j-th order polynomial for j from 0 up to the order of the generating function minus one.
# You have equal numbers of unknowns and data points, so the polynomial fit will be an *exact* solution
# (or as close as rounding point representation can get,
# and also since no two terms in the polynomial are linearly codependent),
# so there is no need to worry about fitting errors.
#
# Then just evaluate the polynomial one away from the max X value, and add that in.

import numpy as np


def main():
    o = 10
    s = 0
    for j in range(2, o+2):
        xdata = np.array(range(1, j))
        ydata = np.array([1-i+i**2-i**3+i**4-i**5+i**6-i**7+i**8-i**9+i**10 for i in range(1, j)])
        print ('xdata :      ',xdata,'             ydata :    ' ,ydata)
        pf = np.polyfit(xdata, ydata, j-2)
        print (pf,'\n------------------------------')
        myval = np.polyval(pf, j)
        s += myval
    print ('\n\nAnswer :    ',s)

main()

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

print('\n--------------------------SOLUTION 5,  discrete derivation --------------------------')
t1  = time.time()

# ==== Sun, 13 Mar 2016, 11:18, Pyviv, France
# No need to guess the formula, you can use discrete derivation: computing differences iteratively.


def suite(n):
    return 1 - n + n*n - n**3 + n**4 - n**5 +n**6 - n**7 + n**8 - n**9 +n**10

def suite_guess(L):
    if len(L) == 1:
        return L[0]
    NL = [L[i] - L[i-1] for i in range(1,len(L))]
    return L[-1]+suite_guess(NL)

def response():
    s = 0
    L = [suite(1)]
    for i in range(2,12):
        guess = suite_guess(L)
        un = suite(i)
        if guess != un:
            s+=guess
        L.append(un)
    return print(s)

response()

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 6, LAGRANGE INTERPOLATION  --------------------------')
t1  = time.time()

# ==== Fri, 30 Dec 2016, 08:43, pkoes, USA
# Lagrange interpolation. Nothing novel here compared to existing posts....

import functools, operator
def lagrange_k(sequence, k):
    if len(sequence) == 1:
        return lambda x: 1
    else:
        return lambda x: functools.reduce(operator.mul, [(x - j)/(k - j) for j in sequence if j != k])

def lagrange(sequence):
    sequence = dict( (float(k), float(v)) for (k, v) in sequence.items())
    return lambda x: sum( v*lagrange_k(sequence, k)(x) for (k, v) in sequence.items() )

def FIT(k, sequence):
        seq = sequence[:k]
        poly = lagrange(dict(seq))
        return poly(sequence[k][0])

def solution(sequence):
        return sum( FIT(k, sequence) for k in range(1, len(sequence)))

u_n = lambda x: 1 - x + x**2 - x**3 + x**4 - x**5 + x**6 - x**7 + x**8 - x**9 + x**10
sequence = [(k, u_n(k)) for k in range(1, 12)]
solution(sequence)

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 7, LAGRANGE INTERPOLATION  --------------------------')
t1  = time.time()

# ==== Sun, 5 Jun 2016, 00:58, azax1, USA
# Lagrange interpolation!

def choose(n, k):
    prod = 1
    m = n
    while m > n - k:
        prod *= m
        m -= 1
    while k > 1:
        prod /= k
        k -= 1
    return prod

summ = 0
limit = 11
seq = [ 1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10 for n in range(1, limit) ]
for i in range(0, limit - 1):
    s = 0
    for j in range(0, i + 1):
        s += (-1)**j * seq[j] * choose(i + 1, j)
    summ += abs(s)


print (summ)


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 8,  successive sequences to the values of f(n)--------------------------')
t1  = time.time()

# ==== Sun, 14 Jun 2015, 17:36, Probably_Disturbed, USA
# I used a "simple" method of calculating the next term in a sequence.
# I did this for successive sequences corresponding to the values of f(n).  Runs in 10 ms.


def f(n):
    return n**10 - n**9 + n**8 - n**7 + n**6 - n**5 + n**4 - n**3 + n**2 - n + 1

seq = [f(n) for n in range(1, 12)]

def p(s):
    n = len(s) + 1
    c = 0
    for q in s:
        seq = s[:]
        seq.remove(q)
        x = q
        for p in seq:
            x *= (n - s.index(p) - 1)/(s.index(q) - s.index(p))
        c += x
    return c

print(int(sum(p(seq[:n]) for n in range(len(seq)))))

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 9, numpy linalg, Linear algebra --------------------------')
t1  = time.time()

# ====Tue, 30 Jun 2015, 12:49, fdemichelis, France
# Solution using numpy


import numpy as np
l=[sum(((-x)**i for i in range(11))) for x in range(1,11) ]
sr=0
for i in range(1,11):
    A=np.array([ [ k**i for i in range(i)] for k in range(1,i+1)],dtype=np.float64)
    B=np.reshape(l[:i],(i,1))
    C=np.dot(np.linalg.inv(A),B)
    v=sum(int(round(C[k][0]))*(i+1)**k for k in range(i))
    sr+=v
print(sr)

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 10, Lagrange polynomials using scipy --------------------------')
t1  = time.time()

# ====Tue, 30 Jun 2015, 12:49, fdemichelis, France
from scipy import interpolate

def u(n): return 1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10

FITs = 0
x = list(range(1, 11))
y = [u(n) for n in range(1, 11)]
for d in range(10):
    z = interpolate.lagrange(x[:d+1], y[:d+1])
    FITs += round(z(d+2))

print(FITs)


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 11, Gaussian elimination --------------------------')
t1  = time.time()

# ====Fri, 27 Feb 2015, 23:54, hacatu, USA
# I just used Gaussian elimination.  My GMP version in C did not work due to overflow,
# so I made a Python version.
# I used rationals to avoid precision problems.  Here is my code, it runs in 156 ms:

def linsolve(eqns):
	n, m = len(eqns), len(eqns[0])
	for c in range(n):
		if eqns[c][c] == 0:
			for s in range(c + 1, n):
				if eqns[s][c]:
					eqns[c], eqns[s] = eqns[s], eqns[c]
					break
			else:
				return None
		for j in range(c, m)[::-1]:
			eqns[c][j] /= eqns[c][c]
		for i in range(n):
			if i == c:
				continue
			for j in range(c, m)[::-1]:
				eqns[i][j] -= eqns[c][j]*eqns[i][c]
	return [row[m - 1] for row in eqns]

def pval(ns, x):
	return sum([n*x**i for (i, n) in enumerate(ns)])

from fractions import Fraction


def optimum(p):
	eqns = [[Fraction(i**j) for j in range(p + 1)] + [ys[i - 1]] for i in range(1, p + 2)]
	return linsolve(eqns)

power = 10
#ns = [Fraction(n) for n in [0, 0, 0, 1]]

ns = [Fraction(-1 if i%2 else 1) for i in range(power + 1)]
ys = [pval(ns, x) for x in range(1, power + 1)]#starts at value for 1
s = Fraction(0)

for p in range(power):
	xs = optimum(p)
	m = p + 2
	#This could be needed sometimes, but it isn't needed here.
	#while pval(xs, m) == pval(ns, m):
	#	m += 1
	s += pval(xs, m)

print(s)

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 12, Newton s Divided Differences --------------------------')
t1  = time.time()

# ====Sat, 8 Nov 2014, 07:59, Krazoid
# Solve using Newton's Divided Differences
# I used Newton's Divided Differences to solve the interpolating polynomial at every step.

# Parameters: n - nth term
# Return: function value of nth term
def P(n):
    return 1 - n + (n**2) - (n**3) + (n**4) - (n**5) + (n**6) - (n**7) +  (n**8) - (n**9) + (n**10)

# Parameters: x - x coordinates of interpolating points
#             y - y coordinates of interpolating points
#             n - number of interpolating points
# Return: coefficients of interpolating polynomial

def newtDD(x,y,n):
    # first coeff is first y value
    coeffs = [y[0]]
    # jump in x coordinate
    i = 1
    # we stop when the jump reaches the number of points
    while(i < n):
        # go until i before last x coordinate
        for j in range(n - i):
            # do Newton's Divided Differences
            y[j] = (y[j + 1] - y[j]) / (x[j + i] - x[j])
        # the first y coordinate will correspond to a coefficient
        coeffs.append(y[0])
        i += 1
    return coeffs

# Parameters: n - number of points given
# Return: value of n+1th term of interpolating poly (which is the error)
def findError(n):
    # if we are given only 1 point
    if(n == 1):
        # the error at the 2nd point will just be P(1)
        return P(1)
    # if we are given more than 1 point
    else:
        error = 0
        # xy-coordinates of points in the polynomial
        x = []
        y = []

        for i in range(1, n + 1):
            x.append(i)
            y.append(P(i))
        # find coeffs of interpolating polynomial
        coeffs = newtDD(x,y,n)
        # do nested multiplication
        for j in range(len(coeffs) - 1, 0, -1):
            if(j == len(coeffs) - 1):
                nest = (((n+1) - x[j - 1])*coeffs[j] + coeffs[j - 1])
            else:
                nest = (((n+1) - x[j - 1])*nest + coeffs[j - 1])
        return nest


def main():
    # degree of polynomial we are dealing with
    degree = 10
    # sum of the errors
    sumError = 0
    # n + 1 points will give correct interpolation
    # therefore, we need up to and including n points to find the errors
    for i in range(1, degree + 1):
        sumError += findError(i)
    print("The sum of the errors is: " + str(sumError))

main()

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 13, numpy polyfit --------------------------')
t1  = time.time()

# ====Tue, 2 Dec 2014, 12:25, dwellwisely, USA
# Another short Python numpy solution (cheat?), using polyfit.
# I am using the form (n^11+1)/(n+1) for the polynomial in the problem.

import numpy as np
def polyn(n):
  return (n**11+1)//(n+1)

x,y=[],[]
total=0
for i in range(1,11):
  x.append(i)
  y.append(polyn(i))
  coeff=np.polyfit(x,y,i-1)
  total+=np.polyval(coeff,i+1)

print(int(round(total)))

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 14, Surprinsingly Simple --------------------------')
t1  = time.time()

# ====Tue, 18 Mar 2008, 18:48, eterevsky, Russia

u = [[]]

for n in range(1, 11):
  u[0].append((n**11 + 1)/(n + 1))

while len(u[-1]) > 1:
  v = []
  for i in range(len(u[-1]) - 1):
    v.append(u[-1][i+1] - u[-1][i])
  u.append(v)

print (sum(map(sum, u)))


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n--------------------------SOLUTION 15, Surprinsingly Simple --------------------------')
t1  = time.time()

# ====Mon, 5 Feb 2007, 08:05, recursive
# This is much easier than most people are making it to be.
# All you must do is generate all the terms, then iteratively generate the differences between terms
# until you have only one term left.  Simply add all the numbers generated to get the solution.
# In python:


maxo = 10
term = [[sum((-n) ** k for k in range(maxo + 1)) for n in range(1, maxo + 1)]]
diffs = lambda arr: [arr[i + 1] - arr[i] for i in range(len(arr) - 1)]
while len(term[-1]) > 1:
    term.append(diffs(term[-1]))
print (sum(sum(row) for row in term))


t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')


print('\n---------------SOLUTION 16, next_term uses the Method of Differences  --------------------------')
t1  = time.time()

# ====Thu, 7 Jun 2007, 21:05, qq1122qq, Python, England
# Python, result is basically instantaneous. 'next_term' uses the method of differences to find the best next term.
# As noted earlier we could just add all the numbers in the difference table to get the final answer,
# but I preferred to write a function I might be able to reuse in a later problem :).

def f(n): return 1-n+n**2-n**3+n**4-n**5+n**6-n**7+n**8-n**9+n**10

def next_term(terms):
    lines = [terms,]
    while len(lines[-1])>1:
        lines.append([y-x for (x,y) in zip(lines[-1],lines[-1][1:])])
    return sum(line[-1] for line in lines)

print (sum(next_term([f(n) for n in range(1,i+2)]) for i in range(10)))

t2  = time.time()
print('\nCompleted in :', round((t2-t1)*1000,6), 'ms\n\n')

